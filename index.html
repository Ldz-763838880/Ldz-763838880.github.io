<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>研の随笔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="keywords" content="龙族、路明非、楚子航、凯撒·加图索、陈墨瞳、上杉绘梨衣、源稚生、源稚女" />
  
  <meta name="description" content="我们每个人都是一个哀小孩，或许是不知梦的缘故，流离之人追逐幻影">
<meta property="og:type" content="website">
<meta property="og:title" content="研の随笔">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="研の随笔">
<meta property="og:description" content="我们每个人都是一个哀小孩，或许是不知梦的缘故，流离之人追逐幻影">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Pluto">
<meta property="article:tag" content="龙族、路明非、楚子航、凯撒·加图索、陈墨瞳、上杉绘梨衣、源稚生、源稚女">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="研の随笔" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/highlight.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
        <a class="nav-item" href="/null" title
        
        >标签</a>
      
        <a class="nav-item" href="/" title
        
        >关于</a>
      
        <a class="nav-item" href="/" title
        
        >友链</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-1262-可被三整除的最大和" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/06/19/1262-%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/">1262-可被三整除的最大和</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/06/19/1262-%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/" class="article-date">
  <time datetime="2023-06-19T07:59:39.000Z" itemprop="datePublished">2023-06-19</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</p>
<p><strong>示例</strong></p>
<pre><code class="diff">输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/">力扣（LeetCode）1262.可被三整除的最大和</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>贪心<ul>
<li>首先将数组按照对3取余的结果分为3组：[0, 1, 2]，然后0的这一组是保留的结果，剩余的从1和2二个组里进行选择。</li>
<li>这里在选择二者的数量时由于（cnt1 + 2 * cnt2) mod 3 = (cnt1 - cnt2) mod 3的结果需要是0，那么cnt1 和 cnt2的数量范围为[len(mod1 / mod2) - 2, len(mod1 / mod2) - 1, len(mod1 / mod2)]</li>
<li>然后就可以利用二重循环遍历这9中可能性，同时运用贪心的思想，将二个数组进行降序排序，每次优先选择前面的大数作为尝试结果，满足被3整除即可停止遍历</li>
<li>最后直接返回记录的结果与[0]数组之和即可</li>
</ul>
</li>
<li>DP<ul>
<li>首先用f[i, j]表示前i个元素选取若干元素求和后对3取模的结果为j</li>
<li>然后考虑对于当前nums[i]元素，如果选择添加进去，则由f[i - 1,（j - nums[i])mod 3]转移得到，不添加则由f[i - 1, j]转移而来</li>
<li>边界条件f[0,0] = 0, f[0, 1] = -inf , f[0, 2] = -inf,并且每一个i都可以由f[i- 1]的其中一个状态转移过来，所以可以用二维数组，记录f[i - 1]和更新f[i]即可</li>
<li>具体状态转移方程为：<ul>
<li>f[i,j] = max(f[i - 1, j], f[i - 1, (j - nums[i])mod 3) + nums[i])</li>
</ul>
</li>
<li>最后返回f[0]即为对3取模为0的最大求和值</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>贪心<ul>
<li>O(nlog n)</li>
<li>数组排序 + 9次遍历</li>
</ul>
</li>
<li>DP<ul>
<li>O(n)</li>
<li>数组元素遍历一遍更新状态即可</li>
</ul>
</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>贪心<ul>
<li>O(n)</li>
<li>n个元素存储</li>
</ul>
</li>
<li>DP<ul>
<li>O(1)</li>
<li>常数3的空间开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// 贪心 / DP
class Solution:
    def maxSumDivThree(self, nums: List[int]) -&gt; int:
        # 贪心
        res = sum([num for num in nums if num % 3 == 0])
        mod1 = sorted([num for num in nums if num % 3 == 1], reverse = True)
        mod2 = sorted([num for num in nums if num % 3 == 2], reverse = True)

        ans = 0
        b, c = len(mod1), len(mod2)
        for cntb in [b - 2, b - 1, b]:
            if cntb &gt;= 0:
                for cntc in [c - 2, c - 1, c]:
                    if cntc &gt;= 0 and (cntb - cntc) % 3 == 0:
                        ans = max(ans, sum(mod1[:cntb]) +sum(mod2[:cntc]))
        return ans + res

        # DP
        f = [0, -float(&quot;inf&quot;), -float(&quot;inf&quot;)]
        for num in nums:
            g = f[:]
            for i in range(3):
                g[(i + num % 3) % 3] = max(g[(i + num % 3) % 3], f[i] + num)
            f = g
        return f[0]
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   “Einstein was wrong when he said, ‘God does not play dice’. Consideration of black holes suggests, not only that God does play dice, but that he sometimes confuses us by throwing them where they can’t be seen”<br>(爱因斯坦曾说 ‘上帝从不掷骰子’。恰恰相反，黑洞的研究表明上帝的确会掷骰子，偶尔还让骰子销声匿迹，令人徒唤奈何。)<br>        ——斯蒂芬·霍金（Stephen William Hawking,1942.1.8.—2018.3.14）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1130-叶值的最小代价生成树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/31/1130-%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/">1130-叶值的最小代价生成树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/05/31/1130-%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/" class="article-date">
  <time datetime="2023-05-31T02:21:31.000Z" itemprop="datePublished">2023-05-31</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：</p>
<p>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。</p>
<p>如果一个节点有 0 个子节点，那么该节点为叶节点。</p>
<p><strong>示例</strong><br><img src="https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg" alt="二叉树示例"></p>
<pre><code class="diff">输入：arr = [6,2,4]
输出：32
解释：有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values">力扣（LeetCode）1130.叶值的最小代价生成树</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>DP<ul>
<li>自上而下建树</li>
<li>首先考虑问题是将arr数组转化为叶子节点中序遍历的所有二叉树，所以可以将数组先划分任意二个非空子数组，分别作为左子树和右子树，不断递归直到子数组大小为1即为叶子节点，对应一个合法二叉树</li>
<li>然后考虑动态规划方程，使用dp[i][j](i &lt; j )记录区间[i, j]子数组对应的最少代价和，则状态转移方程为：<ul>
<li>dp[i][j] = 0, i = j</li>
<li>dp[i][j] = min(dp[i][k] + dp[k + 1][j] + mval[i][k] * mval[k + 1][j]), i &lt;= k &lt; j, mval代表区间内的最大值</li>
</ul>
</li>
<li>最后返回结果dp[0][n - 1]即为最小代价和</li>
</ul>
</li>
<li>单调栈<ul>
<li>自上而下建树</li>
<li>首先考虑每次取arr相邻的二个数字x和y分别作为左右叶子节点，然后合并取最大值作为新arr值，重复上述步骤直到只剩下一个数则建树完成。所求的是建树过程每一步合并的代价之和即x * y最小</li>
<li>然后考虑合并，当我们访问到arr[i] = x时，如果arr[i - 1] &gt;= x and arr[i + 1] &gt;= x， 则x需要和min(arr[i-1], arr[i + 1])进行合并才能保证代价最小</li>
<li>接着考虑使用单调栈stack进行存储数组遍历时的过程结果<ul>
<li>如果栈非空并且栈顶元素y &lt;= x， 则将栈顶元素y出栈<ul>
<li>如果栈为空或栈顶元素 &gt; x ，则将 x 与 y 合并代价最小，为 x * y</li>
<li>否则合并 y 与栈顶元素，合并代价为 stack[-1] * y</li>
<li>操作结束后将 x 入栈</li>
</ul>
</li>
<li>最后得到一个严格递减的单调栈，如果长度 &gt; 2，则表示还有节点需要合并，此时只要按照顺序合并并计算合并代价即可</li>
</ul>
</li>
<li>最后返回总的合并代价即为最小的合并代价值</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>DP<ul>
<li>O(n^3)</li>
<li>三重循环</li>
</ul>
</li>
<li>单调栈<ul>
<li>O(n)</li>
<li>所有元素遍历一遍执行入栈 + 出栈的操作 </li>
</ul>
</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>DP<ul>
<li>O(n^2)</li>
<li>动态规划数组空间大小 n X n</li>
</ul>
</li>
<li>单调栈<ul>
<li>O(n)</li>
<li>栈空间需要O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DP / 单调栈
class Solution:
    def mctFromLeafValues(self, arr: List[int]) -&gt; int:
        #  DP
        n = len(arr)
        dp = [[inf for _ in range(n)] for _ in range(n)]
        mval = [[0 for _ in range(n)] for _ in range(n)]
        for j in range(n):
            mval[j][j] = arr[j]
            dp[j][j] = 0
            for i in range(j - 1, -1, -1):
                mval[i][j] = max(arr[i], mval[i + 1][j])
                for k in range(i, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + mval[i][k] * mval[k + 1][j])
        return dp[0][n - 1]


        #  单调栈
        res = 0
        stack = []
        for x in arr:
            while stack and stack[-1] &lt;= x:
                y = stack.pop()
                if not stack or stack[-1] &gt; x:
                    res += x * y
                else:
                    res += stack[-1] * y
            stack.append(x)
        while len(stack) &gt;= 2:
            x = stack.pop()
            res += stack[-1] * x
        return res
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   “It would not be much of a universe if it wasn’t home to the people you love.”(如果宇宙不是你所爱的人的家，那宇宙就没有什么意义了。)<br>        ——斯蒂芬·霍金（Stephen William Hawking,1942.1.8.—2018.3.14）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1110-删点成林" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/30/1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/">1110-删点成林</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/05/30/1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/" class="article-date">
  <time datetime="2023-05-30T06:32:25.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>
<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>
<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>
<p><strong>示例</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png" alt="二叉树示例"></p>
<pre><code class="diff">输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-nodes-and-return-forest">力扣（LeetCode）1110.删点成林</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>DFS<ul>
<li>首先判断节点值是否在删除列表中，如果在则左右子树节点成为潜在根节点，不在则继续向下搜索</li>
<li>然后对左右子树的潜在根节点进行判断，如果父节点被删除并且该节点值不在删除列表中，则将该节点变为头节点加入结果列表中</li>
<li>最后返回结果列表即可，注意判断父与子节点值是否删除后的返回结果</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(n)</li>
<li>最多访问n个节点</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
<li>树共有n个节点</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DFS
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -&gt; List[TreeNode]:
        to_delete_set = set(to_delete)
        roots = []
        self.dfs(root, True, to_delete_set, roots)
        return roots

    def dfs(self, node: Optional[TreeNode], is_root: bool, to_delete_set: set[int], roots: List[TreeNode]) -&gt; Optional[TreeNode]:
        if not node:
            return None
        delete = node.val in to_delete_set
        node.left = self.dfs(node.left, delete, to_delete_set, roots)
        node.right = self.dfs(node.right, delete, to_delete_set, roots)
        if delete:
            return None
        else:
            if is_root:
                roots.append(node)
            return node
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   “I have noticed that even people who claim everything is predetermined and that we can do nothing to change it, look before they cross the road.”(我注意到，即使那些声称一切都已注定、人力无法改变天意的人在过马路的时候还是会左看右看。)<br>        ——斯蒂芬·霍金（Stephen William Hawking,1942.1.8.—2018.3.14）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1091-二进制矩阵中的最短路径" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/26/1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">1091-二进制矩阵中的最短路径</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/05/26/1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="article-date">
  <time datetime="2023-05-26T07:34:34.000Z" itemprop="datePublished">2023-05-26</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。</p>
<p>二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p>
<p>路径途经的所有单元格都的值都是 0 。<br>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p>
<p><strong>示例</strong><br><img src="https://assets.leetcode.com/uploads/2021/02/18/example1_1.png" alt="矩阵示例"></p>
<pre><code class="diff">输入：grid = [[0,1],[1,0]]
输出：2
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-path-in-binary-matrix">力扣（LeetCode）1091.二进制矩阵中的最短路径</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>经典BFS<ul>
<li>首先判断出发点是否为0，不是则不存在路径返回-1</li>
<li>然后用队列进行BFS遍历所有节点，同时初始化一个二维数组dist记录各个节点的最短路径，初始化为无穷大，dist[0][0] = 1</li>
<li>接着以队列是否为空为条件遍历节点，每次弹出一个节点，判断周围节点下标是否符合条件，以及节点值是否为0，并用当前节点值是否等于前一个节点 + 1 来确定是否被访问过</li>
<li>遍历时当队列出栈的节点为右下角节点时，返回dist[n - 1][n - 1]即可，否则继续遍历并更新节点路径值，同时将下一个满足路径的节点入队列</li>
<li>循环结束则返回 - 1</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(n ^ 2)</li>
<li>最多将n X n大小的矩阵元素都访问一遍</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n ^ 2)</li>
<li>需要一个n X n的数组记录每个节点的最短路径值</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// BFS
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -&gt; int:
        if grid[0][0] == 1:
            return -1
        n = len(grid)
        dist = [[inf] * n for _ in range(n)]
        dist[0][0] = 1
        queue = deque([(0, 0)])
        while queue:
            x, y = queue.popleft()
            if x == y == n - 1:
                return dist[x][y]
            for i in range(-1, 2):
                for j in range(-1, 2):
                    if x + i &lt; 0 or x + i &gt;= n or y + j &lt; 0 or y + j &gt;= n:
                        continue
                    if grid[x + i][y + j] == 1 or dist[x + i][y + j] &lt;= dist[x][y] + 1:
                        continue
                    dist[x + i][y + j] =  dist[x][y] + 1
                    queue.append((x + i, y + j))
        return -1
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   There are only two kinds of force: the sword and thought. From the long terms, the sword is always defeated by thinking men. (世上只有两种力量：利剑和思想。从长而论，利剑总是败在思想手下。)<br>        ——拿破仑（1769.8.15——1821.5.5）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Djangon-Vue-Admin开发" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/15/Djangon-Vue-Admin%E5%BC%80%E5%8F%91/">Djangon-Vue-Admin开发</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/05/15/Djangon-Vue-Admin%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2023-05-15T09:52:16.000Z" itemprop="datePublished">2023-05-15</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>pip安装不上包，尝试换源以及添加–trusted<br><strong>示例</strong></p>
<pre><code class="diff">输入：barcodes = [1,1,1,2,2,2]
输出：[2,1,2,1,2,1]
</code></pre>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1054-距离相等的条形码" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/14/1054-%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/">1054-距离相等的条形码</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/05/14/1054-%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/" class="article-date">
  <time datetime="2023-05-14T07:57:09.000Z" itemprop="datePublished">2023-05-14</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/" rel="tag">最大堆</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。</p>
<p>请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p>
<p><strong>示例</strong></p>
<pre><code class="diff">输入：barcodes = [1,1,1,2,2,2]
输出：[2,1,2,1,2,1]
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distant-barcodes">力扣（LeetCode）1054.距离相等的条形码</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>最大堆<ul>
<li>首先考虑从数量最多的元素开始添加，用最大堆存储元素值和数量</li>
<li>然后每次推出最大数量的元素，如果和上个添加元素不同则直接添加并更新最大堆，相同则推出第二数量的元素添加并更新堆</li>
<li>最后输出res即可</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(n log（n）)</li>
<li>n个元素需要插入，同时每次插入调整堆的时间复杂度为log（n）</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
<li>一共有n个元素</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// 最大堆
class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]:
        cnt = Counter(barcodes)
        q = []
        for num,c in cnt.items():
            heapq.heappush(q, (-c, num))
        res = []
        while len(q) &gt; 0:
            cx, num = heapq.heappop(q)
            if len(res) == 0 or res[-1] != num:
                res.append(num)
                if cx &lt; -1:
                    heapq.heappush(q, (cx + 1, num))
            else:
                cy, numy = heapq.heappop(q)
                res.append(numy)
                if cy &lt; -1:
                   heapq.heappush(q, (cy + 1, numy))
                heapq.heappush(q, (cx, num))
        return res
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   The word impossible, only found in the dictionary of fools. （不可能这个字，只在愚人的字典中找得到。）<br>        ——拿破仑（1769.8.15——1821.5.5）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1048-最长字符串链" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/27/1048-%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/">1048-最长字符串链</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/04/27/1048-%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/" class="article-date">
  <time datetime="2023-04-27T09:22:02.000Z" itemprop="datePublished">2023-04-27</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给出一个单词数组 words ，其中每个单词都由小写英文字母组成。</p>
<p>如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。</p>
<p>例如，”abc” 是 “abac” 的 前身 ，而 “cba” 不是 “bcad” 的 前身<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;= 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k == 1 的 单词链 。</p>
<p>从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。</p>
<p><strong>示例</strong></p>
<pre><code class="diff">输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]
输出：4
解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://https//leetcode.cn/problems/longest-string-chain">力扣（LeetCode）1048.最长字符串链</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>动态规划<ul>
<li>首先考虑以单词word为结尾的词链，则前一个词必然是word减一个单词的，每个单词的初始最大词链长度都为1</li>
<li>然后考虑使用字典cnt存储单词word为尾部词链结尾时的最大长度，通过减少当前word的字母去查找前一个单词是否cnt出现过，出现过则最大长度须更新</li>
<li>动态规划递归方程为：cnt[word] = max(cnt[word], cnt[pre_word]+1],pre_word = {word依次减少一个字母集合}</li>
<li>最后使用中间变量比较每个cnt[word]并记录最大值即可</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(n X m X (log n + m))</li>
<li>n代表单词个数，m表示单词平均长度，排序时间复杂度n X m X logn，每个单词需要查询其前身并比较时间复杂度n X m X m</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n X m)</li>
<li>存储n个单词，每个单词平均长度m，需要空间n X m</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DP
class Solution:
    def longestStrChain(self, words: List[str]) -&gt; int:
        cnt = defaultdict(int)
        words.sort(key = len)
        res = 0
        for word in words:
            cnt[word] = 1
            for i in range(len(word)):
                pre = word[:i] + word[i + 1:]
                if pre in cnt:
                    cnt[word] = max(cnt[word], cnt[pre] + 1)
            res = max(res, cnt[word])
        return res
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   The real talent is resolute aspirations.（真正的才智是刚毅的志向。）<br>        ——拿破仑（1769.8.15——1821.5.5）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1105-填充书架" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/24/1105-%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/">1105-填充书架</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/04/24/1105-%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/" class="article-date">
  <time datetime="2023-04-24T07:30:53.000Z" itemprop="datePublished">2023-04-24</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给定一个数组 books ，其中 books[i] = [thicknessi, heighti] 表示第 i 本书的厚度和高度。你也会得到一个整数 shelfWidth 。</p>
<p>按顺序 将这些书摆放到总宽度为 shelfWidth 的书架上。</p>
<p>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelfWidth ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。</p>
<p>需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。</p>
<p>例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。<br>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。</p>
<p>以这种方式布置书架，返回书架整体可能的最小高度。</p>
<p><strong>示例</strong><br><img src="https://assets.leetcode.com/uploads/2019/06/24/shelves.png" alt="书架摆放"></p>
<pre><code class="diff">输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/filling-bookcase-shelves">力扣（LeetCode）1105.填充书架</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>动态规划<ul>
<li>首先考虑使用dp存储放到第i本书时的最低高度</li>
<li>其次考虑按照书的顺序进行遍历，当放到第i本书时，前j本书的最低高度dp[j] + j &lt;= k &lt;= i 区间书的最大高度就是当前第i本书的最低高度值</li>
<li>动态规划递归方程为：dp[i] = min(dp[i], dp[j] + maxHig(j&lt;= k &lt;= i)]</li>
<li>最后返回dp[n]就是n本书的最低高度值</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(n^2）</li>
<li>n本书，每本书需要遍历前面的书</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
<li>存储n本书的最低高度数组dp</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DP
class Solution:
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -&gt; int:
        n = len(books)
        dp = [inf] *(n + 1)
        dp[0] = 0
        for i, b in enumerate(books):
            curWid, maxHig = 0, 0
            j = i
            while j &gt;= 0:
                curWid += books[j][0]
                if curWid &gt; shelfWidth:
                    break
                maxHig = max(maxHig, books[j][1])
                dp[i + 1] = min(dp[i + 1], dp[j] + maxHig)
                j -= 1
        return dp[n]
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   The only thing that interferes with my learning is my education.（妨碍我学习的唯一障碍就是我的教育。）<br>        ——阿尔伯特·爱因斯坦（1879.3.14——1955.4.18）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1027-最长等差数列" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/22/1027-%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/">1027-最长等差数列</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/04/22/1027-%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/" class="article-date">
  <time datetime="2023-04-22T07:58:06.000Z" itemprop="datePublished">2023-04-22</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。</p>
<p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], …, nums[ik] ，且 0 &lt;= i1 &lt; i2 &lt; … &lt; ik &lt;= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 &lt;= i &lt; seq.length - 1) 的值都相同，那么序列 seq 是等差的。</p>
<p><strong>示例</strong></p>
<pre><code class="diff">输入：nums = [3,6,9,12]
输出：4
解释：
整个数组是公差为 3 的等差数列。
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-arithmetic-subsequence">力扣（LeetCode）1027.最长等差数列</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>动态规划<ul>
<li>首先可以确定等差子序列的公差范围是[-diff, diff] , diff = max(nums) - min(nums)，可以使用字典f来存储以num为结尾的最长子序列长度</li>
<li>其次考虑访问到数组第i个元素时如果将当前num作为最后一个等差元素加入子序列，则f[num] = max(f[num], f[num - d] + 1)，若不加入则f[num] = max(f[num], 1)</li>
<li>最后在遍历中用ans记录f[num]的最大值即可</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(nC）</li>
<li>数组有n个元素，等差子序列公差范围为C</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
<li>哈希表f的空间为n个元素</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DP
class Solution:
    def longestArithSeqLength(self, nums: List[int]) -&gt; int:
        minv, maxv = min(nums), max(nums)
        diff = maxv - minv
        ans = 1

        for d in range(-diff, diff + 1):
            f = dict()
            for num in nums:
                if (prev := num - d)  in f:
                    f[num] = max(f.get(num, 0), f[prev] + 1)
                    ans = max(ans, f[num])
                f[num] = max(f.get(num, 0), 1)
        return ans
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   Two things are infinite: the universe and human stupidity; and I’m not sure about the universe.（宇宙中唯有两件事物是无限的：宇宙的大小与人的愚蠢，我不能确定的是宇宙的大小。）<br>        ——阿尔伯特·爱因斯坦（1879.3.14——1955.4.18）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-1043-分隔数组以得到最大和" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/19/1043-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C/">1043-分隔数组以得到最大和</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/04/19/1043-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C/" class="article-date">
  <time datetime="2023-04-19T12:48:21.000Z" itemprop="datePublished">2023-04-19</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给你一个整数数组 arr，请你将该数组分隔为长度 最多 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p>
<p>返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。</p>
<p><strong>示例</strong></p>
<pre><code class="diff">输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：数组变为 [15,15,15,9,10,10,10]
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-array-for-maximum-sum">力扣（LeetCode）1043.分隔数组以得到最大和</a><br><a id="jump_8"></a></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h2><ul>
<li>动态规划<ul>
<li>考虑将第i个元素当作当前数组最后一个元素进行划分，从第[i - k, i - 1]范围内枚举arr[j],用maVal记录以arr[j]结尾的最大数组值并求和从而进行更新d[i]</li>
<li>状态转移方程：d[i] = max(d[i], d[j] + maxVal * (i - j))</li>
</ul>
</li>
</ul>
<h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h2><ul>
<li>时间复杂度<ul>
<li>O(nk）</li>
<li>数组有n个元素，每个元素倒序遍历前面k个元素</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
<li>dp数组空间大小n，记录对应位置的最大数组求和值</li>
</ul>
</li>
</ul>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4 代码"></a>4 代码</h2><pre><code class="python">// DP
class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -&gt; int:
        n = len(arr)
        d = [0] * (n + 1)
        for i in range(1, n + 1):
            maxVal = arr[i - 1]
            for j in range(i - 1, max(-1, i - k - 1), -1):
                d[i] = max(d[i], d[j] + maxVal * (i - j))
                if j &gt; 0:
                    maxVal = max(maxVal, arr[j - 1])
        return d[n]
</code></pre>
<h3 id="每日一言"><a href="#每日一言" class="headerlink" title="每日一言"></a>每日一言</h3><blockquote>
<p>   I never think of the future. It comes soon enough.（我从不去想未来, 因为它来得已经够快的了）<br>        ——阿尔伯特·爱因斯坦（1879.3.14——1955.4.18）</p>
</blockquote>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        Pluto
      
    </h3>
    <p class="avatar-slogan">
      Universe
    </p>
  </div>
</div>


  
    

  
    
  <div class="widget-box">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/" rel="tag">最大堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E8%AE%B0%E9%81%8D%E5%8E%86/" rel="tag">标记遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/" rel="tag">简单模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/" rel="tag">随机化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BE%99%E6%97%8F/" rel="tag">龙族</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/DFS/" style="font-size: 13.33px;">DFS</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 16.67px;">动态规划</a> <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">单调栈</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/" style="font-size: 10px;">最大堆</a> <a href="/tags/%E6%A0%87%E8%AE%B0%E9%81%8D%E5%8E%86/" style="font-size: 10px;">标记遍历</a> <a href="/tags/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/" style="font-size: 10px;">简单模拟</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/" style="font-size: 10px;">随机化</a> <a href="/tags/%E9%BE%99%E6%97%8F/" style="font-size: 10px;">龙族</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/19/1262-%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/">1262-可被三整除的最大和</a>
          </li>
        
          <li>
            <a href="/2023/05/31/1130-%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91/">1130-叶值的最小代价生成树</a>
          </li>
        
          <li>
            <a href="/2023/05/30/1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/">1110-删点成林</a>
          </li>
        
          <li>
            <a href="/2023/05/26/1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">1091-二进制矩阵中的最短路径</a>
          </li>
        
          <li>
            <a href="/2023/05/15/Djangon-Vue-Admin%E5%BC%80%E5%8F%91/">Djangon-Vue-Admin开发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://yiluyanxia.github.io/" title target='_blank'
        >一路眼瞎</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2023 Pluto &nbsp;&nbsp;
    驱动于 <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a target="_blank" rel="noopener" href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/null" class="mobile-nav-link">标签</a>
  
    <a href="/" class="mobile-nav-link">关于</a>
  
    <a href="/" class="mobile-nav-link">友链</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>